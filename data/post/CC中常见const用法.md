# 简介
**const**名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用**const**，可以避免在函数中对某些不应修改的变量造成可能的改动。（注意要与**static**、）

# const修饰一般常量及数组  
格式：`const` **变量类型** **变量名**;
说明：对于类似这些基本数据类型，修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。比如：  
``` cpp
const int a=10;               
//等价的书写方式：     
int const a=10;
//修改常类型的值(非法操作，编译时会报错)
a = 20;
```

# const修饰指针变量*及引用变量&
- **指针**(pointer)是用来指向**实际内存地址**的变量，一般来说，指针是**整型**，而且一般会以十六进制的格式输出（输出占位符:`%p`）。
- **引用**(reference)是其相应变量的**别名**，用于向函数提供直接访问参数（而不是参数的副本）的途径，与指针相比，引用是一种受限制的指针类型，或者说是指针的一个子集，而从其功能上来看，似乎可以说引用是指针功能的一种高层实现。

**const修饰指针**：
格式一(**指向变量的常指针**):  **变量类型名*** **const** **指针变量名**;
说明：被在*****号右侧的`const`修饰的指针所指向的地址被初始化后就不能被修改了,但其指向的地址的值是可以修改的。
``` cpp
int a[10] = { 0 }, b = 10;
//定义并初始化常指针
int* const ptr_a = &a;
//修改常指针的指向(非法操作，编译时会报错)
ptr_a  = &b;
//修改指向地址的值（可以）
ptr_a[0] = 10;
```
格式二(**指向常量的指针**): **const** **变量类型名*** **指针变量名**;
说明：被在*****号左侧的`const`修饰的指针所指向的是一个常量，该常量的值不能被修改，但是指针的指向确是可以修改的。
``` cpp
char str[] = "world";
//定义并初始化指向常量的指针
const char* ptr_str = "hello";
//修改指针的指向(可以)
ptr_str  = str;
//修改指针指向的地址的值（非法操作，编译时会报错）
ptr_str[0] = 'a';
```
格式二(**指向常量的常指针**): **const** **变量类型名*** **const** **指针变量名**;
说明：这样被两个`const`修饰后，就成了指向常量的的常指针，指针的指向，以及指针指向变量的值均不能被修改。
``` cpp
char str[] = "world";
//定义并初始化指向常量的指针
const char* ptr_str = "hello";
//修改指针的指向(非法操作，编译时会报错)
ptr_str  = str;
//修改指针指向的地址的值（非法操作，编译时会报错）
ptr_str[0] = 'a';
```

**const修饰引用**：
格式一：**const** **引用变量类型名&** **引用变量名** = **引用对象**; 
格式二： **引用变量类型名&** **const** **引用变量名** = **引用对象**; 
说明：(注意:C++引用类型需要在定义时就进行初始化，且初始化后的引用类型不能更换其引用的对象。)方式一和方式二的写法是等价的，引用的对象的值本能被修改。例如：
```cpp
int const &a=x;
const int &a=x;
//这里的效果和int &a一样。
int &const b=x;
//下面为非法操作，编译时会报错(变量被修斯为常量，其值不能被修改)
a++;
```

# const修饰函数
`const`修饰函数主要有两种用法：
- **作为参数的const修饰符**：修饰参数的`const`，如 `void func1(const A* a );`、 `void func2(const A& a)`等；调用函数的时候，用相应的变量初始化`const常量`，则在函数体中，按照const所修饰的部分进行**常量化**，如形参为const A* a，则不能对传递进来的指针指向的地址的内容进行改变，保护了原指针所指向的内容；如形参为const A& a，则不能对传递进来的引用对象进行改变，保护了原对象的属性。
``` cpp
void func1(const char* str,const int& num)
{
    //非法操作，不能对被const修饰的形参的值进行改变
    *str = 'a';
    //非法操作，不能对被const修饰的形参的值进行改变
    num++;
    
    //正确操作，可以用来给其他变量进行初始化等
    std::string str2(str);
    int num2 = num;
}
```
- **作为函数返回值的const修饰符**：这样声明了返回值后，`const`按照"**修饰原则**"进行修饰（及正常的修饰规则），起到相应的保护作用。（通常用在运算符重载函数中使用比较多）

# 类中定义并使用常量（const的特殊用法）
在类中实现常量的定义大致有这么几种方式实现： 
- **使用枚举类型**
``` cpp
class test
{
     enum { SIZE1 = 10, SIZE2 = 20}; // 枚举常量
     int array1[SIZE1];  
     int array2[SIZE2];
};
```

- **使用const** 
注意：不能在类声明中初始化`const数据成员`。const数据成员的初始化只能在**类构造函数**的**初始化表**中进行。
``` cpp
class A
 {…
        A(int size);      // 构造函数
        const int NUM = 100; //错误，不能在类声明中初始化const数据成员
        const int SIZE ; 
 };
 A::A(int size) : SIZE(size)    // 构造函数的初始化表
{
      …
}
//再构造函数内部也不能对被`const`修饰的成员变量进行初始化操作，所以error 赋值的方式是不对的
A::A(int size)
{
     SIZE=size;
}
void main（）
{
    A  a(100); // 对象 a 的SIZE值为100
    A  b(200); // 对象 b 的SIZE值为200
}
```

- **使用static const** 
通过结合静态变量来实现:
``` cpp
#include<iostream>
class Year
{ 
private:
 int y; 
public:
 //定义静态常成员变量
 static int const Inity;
public: 
 Year()
 {
  y=Inity;
 }
 };
//静态变量的赋值方法,注意必须放在类外定义
int const Year::Inity=1997;
void main()
{
    //注意调用方式，这里是用类名调用的(因为静态对象成员，在编译时就被初始化，并储存在全局变量储存区（静态变量储存区）中，所以在这里不用定义对象也可以访问该静态成员变量)。
    std::cout << Year.Inity << std::endl;
}
```

# const定义常量对象
常量对象只能调用常量函数，别的成员函数都不能调用。 
``` cpp
class test
{
public:
    test():x(1)
    {
        y=2;
    }
    ~test()
    {}
    void set(int yy)
    {
        y=yy;
    }
    //声明并实现常成员函数
    int getx() const
    {
        return x;
    }
protected:
    //定义常成员变量
    const int x;
    int y;
};
void main()
{
    const test t;
    //访问出错，常量对象不能调用除常量函数以外的其他函数
    t.set(33);
    //正确操作
    t.getx();
}
```